## Ch10. 예외
---
<br>

## item 69. 예외는 진짜 예외 상황에만 사용하라
        Use exceptions only for exceptional conditions

---

```java
try {
    int i = 0;
    while (true)
        range[i++].climb()
} catch (ArrayIndexOutOfBoundsException e) {
}
```
- 위의 코드는 예외를 잘못 사용한 케이스
- 무한 루프를 돌다 배열의 마지막을 넘어가면 예외를(ArrayIndexOutOfBoundsException) 발생하며 끝내는 코드임
- 아래는 표준적인 관용구로 작성된 코드인데 훨씬 간단하며 직관적인 코드임

```java
for (Mountain m: range)
    m.climb();
```

- 그렇다면 첫번째 코드처럼 작성한 이유는 무엇일까?
- JVM은 배열에 접근할 때마다 경계를 배열의 마지막에 도달했는지 검사하는데, 반복문 또한 배열의 마지막에 도달하면 종료함
- 아마 이러한 중복 검사를 생략하려고 위와 같이 작성한듯 하지만 세가지 측면에서 잘못되었음

<br>


**1. 예외는 예외 상황에 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼 빠르게 만들어야 할 동기가 약함(최적화에 별로 신경쓰지 않았을 가능성이 크다)**

**2. 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한되며**

**3. 배열을 순회하는 표준 관용구는 앞서 걱정한 중복 검사를 수행하지 않는다. (JVM 이 알아서 최적화해 없애줌)**
   
<br>

- 따라서 첫번쨰 코드는 불필요한 예외가 사용됨에 따라 성능도 느려지고 심지어는 원하는 방향대로 작동하지 않을 수 있다
- 만약 반복문 내에 버그가 존재하더라도 흐름 제어에 사용된 예외 때문에 이 버그의 디버깅이 어려워질 수 있다

<br>

- **예외는 오직 예외 상황에서만 사용하라 (절대 흐름 제어용으로 사용하면 안됨)**
- **잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야함**

<br>

### 잘 설계된 API란?
- 잘 설계된 API는 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야함
- 즉, **상태 의존적인 메소드**를 제공하는 클래스는 **상태 검사 메소드**도 같이 제공해줘야 함
        - ex) Iterator 인터페이스의 next(상태 의존적 메소드)와 hasNext(상태 검사 메소드)를 제공

```java
// iterator 표준 관용구
for (Iterator<Foo> i = collection.iterator(); i.hashNext();){
    Foo foo = i.next();
    ...
}
```

```java
// Iterator가 hashNext를 제공하지 않은, 상태 검사 메서드가 없어 예외 처리로 검사하는 코드
try {
    Iterator<Foo> i = collection.iterator();
    while(true) {
        Foo foo = i.next();
        ...
    }
} catch (NoSuchElementException e){

}
```
- 제일 처음의 코드와 유사
- 반복문에 예외를 사용하여 장황하고 헷갈리며 속도도 느림

<br>

### 정리
- **예외는 예외 상황에서 쓸 목적으로 설계되었으며, 정상적인 제어 흐름에서 사용해선 안됨**

<br>

## item 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 비검사 예외를 사용하라
        Use checked exceptions for recoverable conditions and runtime exceptions for programming errors
---

- 자바에서는 **문제 상황을 알리는 타입(Throwable)**으로 검사 예외, 비검사 예외(런타임)/에러 등을 제공하는데,
- 각 타입별로 언제, 무엇을 사용해야하는지 헷갈리는 경우가 있음

<Br>

### 호출하는 쪽에서 복구하리라 여겨지는 상황 => 검사 예외(Checked Exception)
- 검사 예외를 던지면 호출자가 예외를 catch 로 잡아서 처리하거나, 바깥으로 throw 하도록 강제함
- 검사 예외는 일반적으로 복구할 수 있는 조건일 때 발생함
- 따라서 **호출자가 예외 상황에서 벗어나는데 필요한 정보를 알려주는 메소드를 함께 제공하는 것이 중요**

<br>

- **비검사 throwable에는 런타임 예외와 에러, 두가지가 있는데**
- 이 둘은 프로그램에서 잡을 필요가 없거나 혹은 통상적으로 잡지 말아야 함
- 왜냐하면 프로그램에서 비검사 예외나 에러를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득이 없다는 뜻이기 때문

<br>

### 프로그래밍 오류를 나타낼 때 => 런타임 예외(Runtime Exception)
- 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생
- 전제조건을 만족하지 못한 상황이란 -> 클라이언트가 해당 API 의 명세에 기록된 제약을 지키지 못했다는 뜻
- 그런데 이때 이러한 상황들이 복구가 가능한지 불가능한지 판단하기 쉽지않음 -> API 설계자의 판단에 달림

<Br>


### JVM이 자원부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황 => 에러(Error)
- 에러는 프로세스가 더이상 수행될 수 없는 상황이므로 해당 프로세스를 종료함
- 관례상 java 에서 error 는 상속해서 재구현하거나 하는 일은 추천하지 않는다고 함
- 즉, 우리가 구현하는 비검사 throwble은 모두 RuntimeException의 하위 클래스여야 함

<Br>

### 상태 제공 메서드
- 예외가 발생한 경우 어떤 상태때문에 예외가 발생했는지 알아야 쉽게 복구가 가능함
- 따라서 상태를 확인할 수 있는 메서드를 제공해주는게 좋음

<Br>

### 정리
- **복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자**
    - 확실하지 않다면 비검사 예외를 던지자.
- **검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자**

<br>

## item 71. 필요없는 검사 예외 사용은 피하라
        Avoid unnecessary use of checked exceptions
---

### 검사 예외
- 검사 예외의 경우 잘만 활용하면 API와 프로그램의 질을 향상시킬 수 있음
- 그러나, 남발하게 된다면 사용하기 불편한 API가 됨
    - 호출하는 쪽에서 catch 블록으로 예외를 붙잡거나, 바깥으로 던져서 전파해야 함 -> 클라이언트에 부담이 됨
- 더 나은 방식이 없다면 비검사 예외를 사용

<Br>

### 개선 방안
- 검사 예외를 피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것 (item 55)
- 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꾸는 것

<br>

- **리팩터링 전**
```java
try {
    obj.action(args);
} catch (TheCheckedException e) {
    ... // 예외 상황에 대처한다.
}
```
<br>

- **리팩터링 후**
```java
if (obj.actionPermitted(args)) {
    obj.action(args);
} else {
    ...
}
```
- 위와 같이 try-catch 블록을 boolean 값을 반환하는 메서드로 리팩터링할 수 있는데
- 위의 리팩터링 방법을 모든 경우에 적용할 수도 없고, 더 깔끔/직관적이진 않을 수 있지만 더 유연하게 사용할 수 있다고 함

<br>

### 정리
- 꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안전성을 높여주지만, 남용한다면 고통스러운 API가 만들어진다
- API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자
- 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자
- 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자


<br>


## item 72. 표준 예외를 사용하자
        Favor the use of standard exceptions
---

- 자바에는 이미 널리 사용중인 표준 예외들이 많음
- 대부분의 케이스들이  표준예외로 핸들링이 됨

<Br>


### 자주 쓰이는 표준예외

1. IllegalArgumentException -> 허용하지 않는 인수값을 던졌을때 

2. IllegalStateException-> 해당 객체가 메서드를 수행할 수 없는 상태일때

3. NullPointerException-> null을 허용하지 않는 메서드에 null을 줄때

4. UnsupportedOperationException -> 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을때

5. IndexOutOfBoundsException -> 인덱스 범위가 넘어갔을때

6. ConcurrentModificationException-> 단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시 수정하려 할 때

<Br>

### 표준 예외 사용의 장점
- 다른 개발자들이 익히고, 사용하기 쉬우며 의사소통시에 편함
- 예외 클래스의 수가 적을수록 메모리 사용량이 줄고,
- 클래스를 적재하는 시간도 적음

<br>
    
### 정리
- 